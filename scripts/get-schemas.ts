//@ts-ignore
import { jsonToSchema } from "@walmartlabs/json-to-simple-graphql-schema/lib";
import { existsSync, mkdirSync, writeFileSync } from "fs";
import Hermes, { HttpMethods } from "hermes-http";
import { join } from "path";
import visitApis from "../config/nodes-api.json";

export type VisitApi = {
  folder?: string;
  filename: string;
  endpoint: string;
  method: string;
  body?: any;
  headers?: any;
};

const deepMapKeys = (obj: any, f: (key: string) => string): any =>
  Array.isArray(obj)
    ? obj.map((val) => deepMapKeys(val, f))
    : typeof obj === "object"
    ? Object.keys(obj).reduce((acc: any, current: any) => {
        const val = obj[current];
        acc[f(current)] =
          val !== null && typeof val === "object"
            ? deepMapKeys(val, f)
            : (acc[f(current)] = val);
        return acc;
      }, {})
    : obj;

const toCamelCase = (str: string = "") => {
  let s = str
    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)!
    .map((x) => x.slice(0, 1).toUpperCase() + x.slice(1).toLowerCase())
    .join("");
  return s.slice(0, 1).toLowerCase() + s.slice(1);
};

const isEmpty = (obj: any) =>
  Object.keys(obj).length === 0 && obj.constructor === Object;

const request = Hermes({ avoidDuplicateRequests: true });

const PascalCase = (s: string) =>
  s.replace(/(\w)(\w*)/g, (_, g1, g2) => g1.toUpperCase() + g2.toLowerCase());

const replaceSchemaName = (name: string, data: any) => {
  const s = jsonToSchema({
    jsonInput: JSON.stringify(deepMapKeys(data, toCamelCase)),
  });
  return s.value.replace("AutogeneratedMainType", PascalCase(name));
};

const generateSchema = async (node: VisitApi) => {
  let str = "";
  if (node.method === "get") {
    const response = await request.get(node.endpoint, {
      headers: isEmpty(node.headers) ? undefined : node.headers,
    });
    str = replaceSchemaName(node.filename, response.data);
  } else {
    const response = await ((request as any)[node.method as any] as any)(
      node.endpoint,
      node.body,
      {
        headers: isEmpty(node.headers) ? undefined : node.headers,
      }
    );
    str = replaceSchemaName(node.filename, response.data);
  }
  return Promise.resolve(str);
};

const path = join(process.cwd(), "schemas");
(async () => {
  for (const node of visitApis) {
    const schema = await generateSchema(node);
    let filename = path;
    const folder = join(filename, node.folder || "");
    if (node.folder !== undefined) {
      if (!existsSync(folder)) {
        mkdirSync(folder);
      }
    }
    const file = join(folder, `${node.filename}.gql`);
    writeFileSync(file, schema);
  }
})();
