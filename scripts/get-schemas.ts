import { jsonToSchema } from "@walmartlabs/json-to-simple-graphql-schema/lib";
import { existsSync, mkdirSync, writeFileSync } from "fs";
import Hermes from "hermes-http";
import { join } from "path";
import visitApis from "../config/nodes-api.json";

export type VisitApi = {
    folder?: string;
    filename: string;
    endpoint: string;
    method: string;
    body?: any;
    headers?: any;
};

const deepMapKeys = (obj: any, f: (key: string) => string): any =>
    Array.isArray(obj)
        ? obj.map((val) => deepMapKeys(val, f))
        : typeof obj === "object"
        ? Object.keys(obj).reduce((acc: any, current: any) => {
              const val = obj[current];
              acc[f(current)] = val !== null && typeof val === "object" ? deepMapKeys(val, f) : (acc[f(current)] = val);
              return acc;
          }, {})
        : obj;

const toCamelCase = (str = ""): string => {
    const s = str
        .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)!
        .map((x) => x.slice(0, 1).toUpperCase() + x.slice(1).toLowerCase())
        .join("");
    return s.slice(0, 1).toLowerCase() + s.slice(1);
};

const isEmpty = (obj: any): boolean => Object.keys(obj).length === 0 && obj.constructor === Object;

const request = Hermes({ avoidDuplicateRequests: true });

const PascalCase = (s: string): string => s.replace(/(\w)(\w*)/g, (_, g1, g2) => g1.toUpperCase() + g2.toLowerCase());

const replaceSchemaName = (name: string, data: any): string => {
    let targetData = data;
    if (Array.isArray(data)) {
        targetData = data[0];
    }
    const s = jsonToSchema({
        jsonInput: JSON.stringify(deepMapKeys(targetData, toCamelCase))
    });
    return s.value.replace("AutogeneratedMainType", PascalCase(name));
};

const generateSchema = async (node: VisitApi): Promise<string> => {
    let str = "";
    if (node.method === "get") {
        const response = await request.get(node.endpoint, {
            headers: isEmpty(node.headers) ? undefined : node.headers
        });
        str = replaceSchemaName(node.filename, response.data);
    } else {
        const response = await ((request as any)[node.method as any] as any)(node.endpoint, node.body, {
            headers: isEmpty(node.headers) ? undefined : node.headers
        });
        str = replaceSchemaName(node.filename, response.data);
    }
    return Promise.resolve(str);
};

const path = join(process.cwd(), "schemas");

(async (): Promise<void> => {
    for (const node of visitApis) {
        const schema = await generateSchema(node);
        const folder = join(path, node.folder || "");
        if (node.folder !== undefined) {
            if (!existsSync(folder)) {
                mkdirSync(folder);
            }
        }
        const file = join(folder, `${node.filename}.gql`);
        writeFileSync(file, schema);
    }
})();
